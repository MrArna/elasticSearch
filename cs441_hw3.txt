In your third homework assignment you will gain experience with functional reactive concurrent distributed programming using Actor messaging systems and with ElasticSearch, a distributed, scalable, and highly available real-time search and analytics platform (https://www.elastic.co/products/elasticsearch). This is the first homework in CS441 where you will write your code in Scala using the Akka toolkit (http://akka.io) and you will build your project using the SBT. Doing this homework is also essential for successful completion of your course project that is based on understanding key modern technologies and functional languages to write programs for processing large data streams. Those who take both CS474 and CS441 will benefit the most from this homework. Also, this homework includes steps that are required for your course project, so by doing this homework you will partially kill (or wound) two birds with one stone.

A goal of this homework is to create a code search engine based on ElasticSearch (https://www.elastic.co/about/partners/google-compute-engine). You will deploy your code search engine in the Google Cloud using your provided Google Cloud accounts. Your client program will take key words from users and then it will make a REST call to your web service that will use the key words to retrieve software projects where these key words are located. As parameters to your web service, clients can specify in what attributes they want to search the key words (e.g., language, committers, issues, or code) and how many results they want to retrieve. Simply put, your client can be httpie (https://github.com/jkbrzt/httpie) or postman or soapui tools, using which we will use to run queries and obtain results based on the code search repository that you will build. You will load test the scaling capabilities of the cloud-based ElasticSearch using SoapUI, where you will create a load of queries for your web service and obtain average response times for different loads. To put succintly, this is a homework that you should not be ashamed of to put on your linkedin profile.

Elasticsearch is a widely used open source full-text search engine and data analysis tool. It is Java-based and Apache Lucene-based. Storing and indexing your data in ElasticSearch allows users to provide quick and relevant results to clients' searches. ElasticSearch is used in many enterprise-strength software projects. My recent experiences include working with applications that process large logs and output results to Elasticsearch together with other logging tools such as Rsyslog (www.rsyslog.com), Logstash (www.elastic.co/products/logstash), and Apache Flume - widely used at Google (http://flume.apache.org). Some applications use a visual interface to search and analyze data, and you may consider using Kibana (www.elastic.co/products/kibana) in this homework.

In this homework, you will use the Ohloh, a free RESTful Application Programming Interface (API) to the Black Duck Open Hub open source directory (https://www.openhub.net/tools) to analyze software projects in this very large open-source repository. There is a lot of information about Ohloh and examples (https://github.com/blackducksoftware/ohloh_api). You will request API keys for your application, and the limit is 1,000 requests per day. Since we have 50 students in this class and assuming that each will analyze 10,000 applications from OpenHub, the total number of the analyzed applications will be 500,000. I created a column in the gradebook on the Blackboard where I specified the starting number of the application range for each student. For example, if you see your starting number 20,000 - it means that you can access your applications in the range of [20000, 29999] (https://www.openhub.net/p/20000 ).

As the first step, your application will stream open-source software projects and metainformation about them from Ohlon to process the streams and to feed the processed data into ElasticSearch to create a search index. In your Scala program, you will create multiple actors that will handle each other's requests by sending and processing messages, which will be desribed using case classes. For example, one actor will handle the list of public repositories of projects written in Java, some other actors will obtain the content of a file or a directory in a repository, some other actors will automatically discard language-specific keywords (e.g., for and while in Java and C and C++) and so on.

Your starting point is to read about Akka (http://akka.io/docs/ in addition to multiple books and forums) and work through its examples to understand the abstractions and the functionality of this toolkit, especially Akka HTTP that I want you to use in this homework. Your starting point is to create a design document that shows a message sequence chart or its equivalent, where the actors communicate using sequences of messages. Also, very helpful is a finite state machine where nodes describe states of the programs and edges describe transitions that are facilitated by the messages that actors exchange. Once you have the initial design, you can start prototyping your program by implementing separate elements of its functionality. In a way, you can view this program as a composition of objects that collaborate via messages. It is also a great opportunity for you to start using the Scala collection library to process data that your program obtains from Ohloh. Finally, your documentation should include the description of your abstractions and how they influenced your design and development.

For an additional bonus (up to 5%!) you can integrate other Ohloh data into your project. Your ideas and creativity are highly welcome and will be rewarded! For example, you can obtain issues for each pulled software project and you can attempt to link these issues to specific code fixes. Or you can link kudos scores to specific commits and rank program modules w.r.t. factoids and commits associated with these modules. In short, your additional bonus will be based on how you connect various sources of information, not on simply downloading bits and pieces of information. Let your imagination fly!

This homework differs from the previous two, since you are allowed to form groups up to three members in a group. If you want to work alone, it is perfectly fine, however, you can decide to work in a group with up to two more of your classmates. Logistically, one of you will create a private fork and will invite one or two of your classmates with the write access to your fork. You should be careful - once you form a group and write and submit your code, you cannot start dividing your work and claim you did most of the work. Your forkmates may turn out to be freeloaders and you will be taken for a free ride. In the end, everyone if your group will be screwed, err, everyone will receive a bad grade. Be very careful and make sure that you trust your classmates before forming your group. Neither your TA not I can and will resolve your internal group conflicts. Your submission will include the names of all of your forkmates and y'all will receive the same grade for this homework. Working in a group will be an excellent opportunity for you to explore branching in the Git, merging, and resolving semantic conflicts when merging your code changes. Don't pass on this opportunity!

If you submitted your previous homework, it means that you were already added as a member of UIC_CS441_2016 team in Bitbucket. Separate repositories are already created for each of your homeworks and for the course project. You will find a corresponding entry for this homework. You will fork this repository and your fork will be private, no one else besides you, the TA and your course instructor will have access to your fork. Please remember to grant a read access to your repository to your TA and your instructor and the write access to your forkmates. You can commit and push your code as many times as you want. Your code will not be visible and it should not be visible to other students except for your forkmates. When you push it, your instructor and the TA will see your code in your separate private fork. Making your fork public or inviting other students besides your team members to join your fork will result in losing your grade. For grading, only the latest push timed before the deadline will be considered. If you push after the deadline, your grade for the homework will be zero. For more information about using the Git and Bitbucket specifically, please use this link as the starting point https://confluence.atlassian.com/bitbucket/bitbucket-cloud-documentation-home-221448814.html. For those of you who still struggle with the Git, I keep recommending a book by Ryan Hodson on Ry's Git Tutorial. The other book called Pro Git is written by Scott Chacon and Ben Straub and published by Apress and it is freely available https://git-scm.com/book/en/v2/. There are multiple videos on youtube that go into details of the Git organization and use.

As your TA specified, please follow this naming convention while submitting your work : "Firstname_Lastname_hw3", so that we can easily recognize your submission. Those who work in groups can use longer names: "Firstname1_Lastname1_Firstname2_Lastname2_Firstname3_Lastname3_hw3". I repeat, make sure that you will give both your TA and me read access to your private forked repository.

As usual, you can post questions and replies, statements, comments, discussion, etc. on Piazza. Remember that you cannot share your code and your solutions beyond your group, but you can ask and advise others using Piazza on where resources and sample programs can be found on the internet, how to resolve dependencies and configuration issues, and how to design the logic of the algorithm. Yet, your implementation should be your own and you cannot share it. Alternatively, you cannot copy and paste someone else's implementation and put your name on it. Your submissions will be checked for plagiarism. When posting question and answers on Piazza, please select the appropriate folder, i.e., hw3 to ensure that all discussion threads can be easily located.

Submission deadline: Sunday, November 6 at 11PM CST. Your submission will include your source code, the SBT build configuration, the README.md file in the root directory that contains the description of your implementation, how to compile and run it using SBT, your SoapUI load tests, and what are the limitations of your implementation. In addition, you will specify the URL for your web service and its interfaces.

THE INSTRUCTOR (and the TA) WILL NOT ANSWER ANY REQUESTS FROM STUDENTS STARTING 5PM THE EVENING OF THE SUBMISSION DEADLINE.

Evaluation criteria:
- the maximum grade for this homework is 7% + up to 5% bonus. Points are subtracted from this maximum grade: for example, saying that 2% is lost if some requirement is not completed means that the resulting grade will be 7%-2% => 4%;
- no comments or highly insufficient comments: up to 2% lost;
- no unit and integration tests: up to 5% lost;
- code does not compile or it crashes without completing the core functionality: up to 5% lost;
- the documentation is missing or insufficient to understand how to compile and run your program: up to 6% lost;
- only a subset of your tests works: up to 3% lost;
- the minimum grade for this homework cannot be less than zero.